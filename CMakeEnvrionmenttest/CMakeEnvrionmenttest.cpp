// CMakeEnvrionmenttest.cpp: 定义应用程序的入口点。
/*1.配置SDL
  2.创建游戏类来控制玩家类，场景类，创建场景基类，目的是不同的场景都继承基类的虚函数
	并重写，以此实现不同场景
  3.游戏类: 初始化玩家，场景，控制事件处理，更新画面（各个类的事件处理函数
	都放在游戏类的事件处理函数，模块化处理）
  4.单例模式:一个类只有一个唯一实例，且提供全局接口，
    Game 类通过 GetInstance() 方法提供了唯一的实例
	通常在第一次调用 GetInstance() 时,保证有且仅有一个 Game 实例被创建
  5.时间补偿机制: 角色移动不受帧率的影响，一帧所花的时间*移动速度=不受帧数影响的速度(一帧所花的时间=1/FPS)
	一秒内若能稳定帧率如每秒60帧:  每帧移动的距离: 10*0.01667=0.1667，一秒移动的的距离: 60*0.1667≈10
	若一秒内帧数不一角色的移动距离依旧不受帧率影响（帧率高导致角色移动快，帧率低导致角色移动慢） :前一帧正常:10*0.01667=0.1667
	后一帧超过正常帧所花时间(正常0.01667s每帧),如后一帧花0.5s,则10*0.5=5，花的时间多了但移动的距离长了，换算成一秒，角色移动距离依旧正常
  6.使用SDL_FPoint来计算向量，数学里用两个坐标表示一个向量，通过将向量的每个分量除以向量的长度（模长），得到的新向量长度为 1，即单位向量。
    单位向量.x=x/sqrt（x*x+y*y）,单位向量.y=x/sqrt（x*x+y*y）
  7.子弹和player,enemy是独立对象，enemy和player的坐标相减获得enemy指向player的向量，将该向量单位化，赋给子弹，并每帧更新，直至敌机销毁
	，在敌机销毁后，direction 是 EnemyBullet 结构体的一个成员变量，它在子弹创建时（通过 GetDirection 方法）被赋值，用于表示子弹的运动方向
	。只要子弹对象存在，它的 direction 属性就存在，并且会按照初始设定的方向继续影响子弹的位置更新。
  8.子弹旋转需要计算单位向量的角度，先获得tanθ=y/x(对边比邻边),再计算arctan(tanθ)=x-(x*x*x)/3=θ(泰勒展开)
	，得到弧度，换算为弧度 = 角度 × (π / 180)，角度 = 弧度 × (180 / π)，角度=弧度*57.3（1rad=57.3°），还要考虑图片纹理的正方向要和游戏逻辑向量的 "正方向" 定义相同(SDL默认x轴为正方向)
	若图片纹理的正方向朝下（y轴），需要减90°与x轴相同
  9.爆炸序列帧使用方法： 创建独立的爆炸函数，需要传入爆炸的敌机，因为需要获取该敌机的位置，方便定位爆炸序列帧的位置，
	在敌机死亡时记录爆炸开始的时间，创建更新爆炸动画的函数，获取当前时间，计算当前时间与当前时间之差，计算爆炸执行到哪一帧，
	爆炸函数内，在渲染的时候通过当前帧索引 × 单帧宽度，就能定位到当前帧在总纹理中的横向位置，因为所有帧横向排列在一张图上
 10.动画的流畅度依赖主循环的 “采样频率”(游戏的主帧率即FPS=60或30，两者的采样帧率分别为16ms,33ms)—— 只要主循环帧率 ≥ 动画 FPS，
	采样间隔就会 ≤ 单帧时长，自然不会跳帧,例如：你的动画 FPS=10，只要主循环帧率≥10（比如游戏稳定在 30FPS/60FPS），采样间隔就会是 33ms/16ms，
	远小于 100ms。此时计算会是：5000ms (0 帧)→5016ms (0.16 帧→取 0 帧)→5032ms (0.32 帧→取 0 帧)→…→5100ms (1 帧)，
	帧索引会 “逐帧递进”，动画流畅。
 11.SDL_PollEvent(event) 的工作机制就是：每次调用时，它会检查事件队列中是否有未处理的事件（包括键盘按键、鼠标移动 / 点击、窗口操作等）。
	如果有事件，就会将事件数据填充到你传入的 event 结构体中，并返回非零值表示有事件处理；如果队列中没有事件，则返回 0
	当你按下 A 键时，SDL 会将一个类型为 SDL_KEYDOWN 的事件放入事件队列
	此时调用 SDL_PollEvent(event) 会获取到这个事件，event 结构体将被填充以下关键信息：
	event.type = SDL_KEYDOWN（表示是按键按下事件）
	event.key.keysym.sym = SDLK_a（表示是 A 键）
	处理完这个按键事件后，循环会继续调用 SDL_PollEvent(event) 检查是否有其他事件
	当你松开 A 键时，会产生一个 SDL_KEYUP 事件，同样会通过 event 结构体传递
 12.利用单位圆的特性，在数学中，三角函数（如 cos、sin）的输入可以是角度，也可以是弧度，但需要明确单位
	而在 C++ 标准库的 cos 和 sin 函数中，必须传入弧度在平面直角坐标系中，一个角度 angle（以弧度为单位）对应单位圆（半径为 1 的圆）
	上的一个点：这个点的 x 坐标 等于 cos(angle)，这个点的 y 坐标 等于 sin(angle)
 13.表面（Surface）确实包含了文本的像素形状，它就像一张 "内存中的位图"，精确记录了每个字符的轮廓和颜色信息（比如哪些位置是文字像素，哪些是透明背景）
	纹理（Texture）可以看作是 "能被 GPU 高效处理的图片"。它本质上是将表面的像素数据转移到 GPU 内存中，并转换为 GPU 支持的格式。
	这张 "图片" 和表面的视觉内容完全一致，但存储和处理方式更适合快速渲染。表面负责承载原始像素信息，纹理负责高效显示这些信息。

  */

#include "CMakeEnvrionmenttest.h"
#include<SDL.h>
#include<SDL_mixer.h>
#include<SDL_image.h>
#include<SDL_ttf.h>
#include<iostream>
#include"Game.h"
#include"Scenc.h"
#include"ScencMain.h"
using namespace std;

int main(int,char**)
{

	Game& game = Game::GetInstance();
	game.Init();
	game.Run();
	return 0;
}
